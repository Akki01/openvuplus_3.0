################################################################################
#      This file is part of OpenELEC - http://www.openelec.tv
#      Copyright (C) 2009-2014 Stephan Raue (stephan@openelec.tv)
#
#  OpenELEC is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 2 of the License, or
#  (at your option) any later version.
#
#  OpenELEC is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with OpenELEC.  If not, see <http://www.gnu.org/licenses/>.
################################################################################
commit 710c9ba0aab6c2d50b046b22f1405b12b7ebbff3
Author: hschang <chang@dev3>
Date:   Tue Feb 25 16:49:51 2014 +0900

    patch for lastest kernel(>= 3.10.0)

diff --git a/core/rtw_debug.c b/core/rtw_debug.c
index 04e472d..d4f6e7d 100644
--- a/core/rtw_debug.c
+++ b/core/rtw_debug.c
@@ -62,6 +62,7 @@
 #ifdef CONFIG_PROC_DEBUG
 #include <rtw_version.h>
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) 
 int proc_get_drv_version(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -75,7 +76,15 @@ int proc_get_drv_version(char *page, char **start,
 	*eof = 1;
 	return len;
 }
+#else
+int proc_get_drv_version(struct seq_file *m, void* data)
+{
+	seq_printf(m, "%s\n", DRIVERVERSION);
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) 
 int proc_get_write_reg(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -83,7 +92,14 @@ int proc_get_write_reg(char *page, char **start,
 	*eof = 1;
 	return 0;
 }
+#else
+int proc_get_write_reg(struct seq_file *m, void* data)
+{
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) 
 int proc_set_write_reg(struct file *file, const char *buffer,
 		unsigned long count, void *data)
 {
@@ -128,10 +144,59 @@ int proc_set_write_reg(struct file *file, const char *buffer,
 	return count;
 	
 }
+#else
+int proc_set_write_reg_open(struct seq_file *m, void* data)
+{
+	return 0;
+}
+
+ssize_t proc_set_write_reg(struct file *file, const char *buffer, size_t count, loff_t *pos)
+{
+	struct net_device *dev = (struct net_device *)pos;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 addr, val, len;
+
+	if (count < 3)
+	{
+		DBG_8192C("argument size is less than 3\n");
+		return -EFAULT;
+	}	
+	len = min(count, sizeof(tmp)-1);
+	if (buffer && !copy_from_user(tmp, buffer, len)) {
+		tmp[len] = '\0';
+		
+		if(sscanf(tmp, "%x %x %x", &addr, &val, &len)!=3) {
+			DBG_8192C("invalid write_reg parameter!\n");
+			return -EFAULT;
+		}
+
+		switch(len)
+		{
+			case 1:
+				rtw_write8(padapter, addr, (u8)val);				
+				break;
+			case 2:
+				rtw_write16(padapter, addr, (u16)val);				
+				break;
+			case 4:
+				rtw_write32(padapter, addr, val);				
+				break;
+			default:
+				DBG_8192C("error write length=%d", len);
+				break;
+		}			
+		
+	}
+	
+	return count;
+}
+#endif
 
 static u32 proc_get_read_addr=0xeeeeeeee;
 static u32 proc_get_read_len=0x4;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) 
 int proc_get_read_reg(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -199,7 +264,77 @@ int proc_set_read_reg(struct file *file, const char *buffer,
 	return count;
 
 }
+#else
+int proc_get_read_reg(struct seq_file *m, void* data)
+{	
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 
+	if(proc_get_read_addr==0xeeeeeeee)
+	{
+		return 0;
+	}
+
+	switch(proc_get_read_len)
+	{
+		case 1:			
+			seq_printf(m, "rtw_read8(0x%x)=0x%x\n", proc_get_read_addr, rtw_read8(padapter, proc_get_read_addr));
+			break;
+		case 2:
+			seq_printf(m, "rtw_read16(0x%x)=0x%x\n", proc_get_read_addr, rtw_read16(padapter, proc_get_read_addr));
+			break;
+		case 4:
+			seq_printf(m, "rtw_read32(0x%x)=0x%x\n", proc_get_read_addr, rtw_read32(padapter, proc_get_read_addr));
+			break;
+		default:
+			seq_printf(m, "error read length=%d\n", proc_get_read_len);
+			break;
+	}
+	return 0;
+}
+
+ssize_t proc_set_read_reg(struct file *file, const char *buf,
+		size_t count, loff_t *pos)
+{
+	struct net_device *dev = (struct net_device *)pos;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	char *cmd, *buffer;
+	
+	u32 addr, len, num;
+
+	if (count < 2)
+	{
+		DBG_8192C("argument size is less than 2\n");
+		return -EFAULT;
+	}	
+	cmd = kmalloc(count+1, GFP_KERNEL);
+	if(!cmd)
+	    return -ENOMEM;
+	if(!copy_from_user(cmd, buf, count)) {
+
+		cmd[count]='\0';
+		buffer = cmd;
+		
+		num = sscanf(buffer, "%x %x", &addr, &len);
+
+		if (num !=  2) {
+			DBG_8192C("invalid read_reg parameter!\n");
+			return count;
+		}
+
+		proc_get_read_addr = addr;
+		proc_get_read_len = len;
+	}else{
+	    kfree(cmd);
+	    return -EFAULT;
+	}
+	kfree(cmd);
+	return count;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_fwstate(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -215,7 +350,18 @@ int proc_get_fwstate(char *page, char **start,
 	*eof = 1;
 	return len;
 }
+#else
+int proc_get_fwstate(struct seq_file *m, void* data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	seq_printf(m, "fwstate=0x%x\n",get_fwstate(pmlmepriv));
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_sec_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -233,7 +379,20 @@ int proc_get_sec_info(char *page, char **start,
 	*eof = 1;
 	return len;
 }
+#else
+int proc_get_sec_info(struct seq_file *m, void* data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	seq_printf(m, "auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
+						psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
+						psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_mlmext_state(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -250,7 +409,19 @@ int proc_get_mlmext_state(char *page, char **start,
 	*eof = 1;
 	return len;
 }
+#else
+int proc_get_mlmext_state(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	seq_printf(m, "pmlmeinfo->state=0x%x\n", pmlmeinfo->state);
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_qos_option(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -267,7 +438,18 @@ int proc_get_qos_option(char *page, char **start,
 	return len;
 
 }
+#else
+int proc_get_qos_option(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	seq_printf(m, "qos_option=%d\n", pmlmepriv->qospriv.qos_option);
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_ht_option(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -283,7 +465,18 @@ int proc_get_ht_option(char *page, char **start,
 	*eof = 1;
 	return len;
 }
+#else
+int proc_get_ht_option(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	seq_printf(m, "ht_option=%d\n", pmlmepriv->htpriv.ht_option);
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_rf_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -301,7 +494,19 @@ int proc_get_rf_info(char *page, char **start,
 	return len;
 
 }
+#else
+int proc_get_rf_info(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;	
+	seq_printf(m, "cur_ch=%d, cur_bw=%d, cur_ch_offet=%d\n",
+			pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_ap_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -350,7 +555,53 @@ int proc_get_ap_info(char *page, char **start,
 	return len;
 
 }
+#else
+int proc_get_ap_info(struct seq_file *m, void *data)
+{
+	struct sta_info *psta;
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	int len = 0;
+
+	psta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
+	if(psta)
+	{
+		int i;
+		struct recv_reorder_ctrl *preorder_ctrl;
+					
+		seq_printf(m, "SSID=%s\n", cur_network->network.Ssid.Ssid);		
+		seq_printf(m, "sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
+		seq_printf(m, "cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);		
+		seq_printf(m, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+		seq_printf(m, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+		seq_printf(m, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
+		seq_printf(m, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
+		seq_printf(m, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);	
+		seq_printf(m, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+					
+		for(i=0;i<16;i++)
+		{							
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+			if(preorder_ctrl->enable)
+			{
+				seq_printf(m, "tid=%d, indicate_seq=%d\n", i, preorder_ctrl->indicate_seq);
+			}
+		}	
+		
+	}
+	else
+	{
+		seq_printf(m, "can't get sta's macaddr, cur_network's macaddr:" MAC_FMT "\n", MAC_ARG(cur_network->network.MacAddress));
+	}
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_adapter_state(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -366,7 +617,18 @@ int proc_get_adapter_state(char *page, char **start,
 	return len;
 
 }
-	
+#else
+int proc_get_adapter_state(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	seq_printf(m, "bSurpriseRemoved=%d, bDriverStopped=%d\n", 
+			padapter->bSurpriseRemoved, padapter->bDriverStopped);
+	return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_trx_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -387,8 +649,23 @@ int proc_get_trx_info(char *page, char **start,
 	return len;
 
 }
-	
-		
+#else
+int proc_get_trx_info(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct recv_priv  *precvpriv = &padapter->recvpriv;
+	seq_printf(m, "free_xmitbuf_cnt=%d, free_xmitframe_cnt=%d, free_ext_xmitbuf_cnt=%d, free_recvframe_cnt=%d\n", 
+		pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt,pxmitpriv->free_xmit_extbuf_cnt, precvpriv->free_recvframe_cnt);
+#ifdef CONFIG_USB_HCI
+	seq_printf(m, "rx_urb_pending_cn=%d\n", precvpriv->rx_pending_cnt);
+#endif
+	return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_rx_signal(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -452,7 +729,62 @@ int proc_set_rx_signal(struct file *file, const char *buffer,
 	return count;
 	
 }
+#else
+int proc_get_rx_signal(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	seq_printf(m,
+		"rssi:%d\n"
+		"rxpwdb:%d\n"
+		"signal_strength:%u\n"
+		"signal_qual:%u\n"
+		"noise:%u\n", 
+		padapter->recvpriv.rssi,
+		padapter->recvpriv.rxpwdb,
+		padapter->recvpriv.signal_strength,
+		padapter->recvpriv.signal_qual,
+		padapter->recvpriv.noise
+		);
+	return 0;
+}
 
+ssize_t proc_set_rx_signal(struct file *file, const char *buffer, size_t count, loff_t *pos)
+{
+	struct net_device *dev = (struct net_device *)pos;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 is_signal_dbg, signal_strength;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+
+		int num = sscanf(tmp, "%u %u", &is_signal_dbg, &signal_strength);
+
+		is_signal_dbg = is_signal_dbg==0?0:1;
+		
+		if(is_signal_dbg && num!=2)
+			return count;
+			
+		signal_strength = signal_strength>100?100:signal_strength;
+		signal_strength = signal_strength<0?0:signal_strength;
+
+		padapter->recvpriv.is_signal_dbg = is_signal_dbg;
+		padapter->recvpriv.signal_strength_dbg=signal_strength;
+
+		if(is_signal_dbg)
+			DBG_871X("set %s %u\n", "DBG_SIGNAL_STRENGTH", signal_strength);
+		else
+			DBG_871X("set %s\n", "HW_SIGNAL_STRENGTH");
+	}
+	return count;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_ampdu_enable(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -499,7 +831,46 @@ int proc_set_ampdu_enable(struct file *file, const char *buffer,
 	return count;
 	
 }
+#else
+int proc_get_ampdu_enable(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+	if(pregpriv)
+		seq_printf(m,
+			"%d\n",
+			pregpriv->ampdu_enable
+			);
+	return 0;
+}
+
+ssize_t proc_set_ampdu_enable(struct file *file, const char *buffer, size_t count, loff_t *pos)
+{
+	struct net_device *dev = (struct net_device *)pos;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+	char tmp[32];
+	u32 mode;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+
+		int num = sscanf(tmp, "%d ", &mode);
+
+		if( pregpriv && mode >= 0 && mode < 3 )
+		{
+			pregpriv->ampdu_enable= mode;
+			printk("ampdu_enable=%d\n", mode);
+		}
+	}
+	return count;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_rssi_disp(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -547,10 +918,52 @@ int proc_set_rssi_disp(struct file *file, const char *buffer,
 	return count;
 	
 }	
+#else
+int proc_get_rssi_disp(struct seq_file *m, void *data)
+{
+	return 0;
+}
+
+ssize_t proc_set_rssi_disp(struct file *file, const char *buffer, size_t count, loff_t *pos)
+{
+	struct net_device *dev = (struct net_device *)pos;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 enable=0;
 
+	if (count < 1)
+	{
+		DBG_8192C("argument size is less than 1\n");
+		return -EFAULT;
+	}	
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+
+		int num = sscanf(tmp, "%x", &enable);
+
+		if (num !=  1) {
+			DBG_8192C("invalid set_rssi_disp parameter!\n");
+			return count;
+		}
 		
+		if(enable)
+		{			
+			DBG_8192C("Turn On Rx RSSI Display Function\n");
+			padapter->bRxRSSIDisplay = enable ;			
+		}
+		else
+		{
+			DBG_8192C("Turn Off Rx RSSI Display Function\n");
+			padapter->bRxRSSIDisplay = 0 ;
+		}
+	}
+	return count;
+}
+#endif
+
 #ifdef CONFIG_AP_MODE
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_all_sta_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -620,14 +1033,74 @@ int proc_get_all_sta_info(char *page, char **start,
 	return len;
 
 }
-	
-#endif		
+#else
+int proc_get_all_sta_info(struct seq_file *m, void *data)
+{
+	_irqL irqL;
+	struct sta_info *psta;
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	int i, j;
+	_list	*plist, *phead;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	seq_printf(m, "sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
+					
+	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+	for(i=0; i< NUM_STA; i++)
+	{
+		phead = &(pstapriv->sta_hash[i]);
+		plist = get_next(phead);
+		
+		while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+		{
+			psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
+
+			plist = get_next(plist);
+
+			//if(extra_arg == psta->aid)
+			{
+				seq_printf(m, "sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
+				seq_printf(m, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+				seq_printf(m, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+				seq_printf(m, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
+				seq_printf(m, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
+				seq_printf(m, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);									
+				seq_printf(m, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+				seq_printf(m, "sleepq_len=%d\n", psta->sleepq_len);
+				seq_printf(m, "capability=0x%x\n", psta->capability);
+				seq_printf(m, "flags=0x%x\n", psta->flags);
+				seq_printf(m, "wpa_psk=0x%x\n", psta->wpa_psk);
+				seq_printf(m, "wpa2_group_cipher=0x%x\n", psta->wpa2_group_cipher);
+				seq_printf(m, "wpa2_pairwise_cipher=0x%x\n", psta->wpa2_pairwise_cipher);
+				seq_printf(m, "qos_info=0x%x\n", psta->qos_info);
+				seq_printf(m, "dot118021XPrivacy=0x%x\n", psta->dot118021XPrivacy);
+								
+				for(j=0;j<16;j++)
+				{							
+					preorder_ctrl = &psta->recvreorder_ctrl[j];
+					if(preorder_ctrl->enable)
+					{
+						seq_printf(m, "tid=%d, indicate_seq=%d\n", j, preorder_ctrl->indicate_seq);
+					}
+				}
+			}
+		}
+	}
+	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	return 0;
+}
+#endif
+
+#endif
 
 #ifdef DBG_MEMORY_LEAK
 #include <asm/atomic.h>
 extern atomic_t _malloc_cnt;;
 extern atomic_t _malloc_size;;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_malloc_cnt(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -641,9 +1114,20 @@ int proc_get_malloc_cnt(char *page, char **start,
 	*eof = 1;
 	return len;
 }
+#else
+int proc_get_malloc_cnt(struct seq_file *m, void *data)
+{
+	seq_printf(m, "_malloc_cnt=%d\n", atomic_read(&_malloc_cnt));
+	seq_printf(m, "_malloc_size=%d\n", atomic_read(&_malloc_size));
+	return 0;
+}
+#endif
+
 #endif /* DBG_MEMORY_LEAK */
 
 #ifdef CONFIG_FIND_BEST_CHANNEL
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_best_channel(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -703,6 +1187,61 @@ int proc_get_best_channel(char *page, char **start,
 	return len;
 
 }
+#else
+int proc_get_best_channel(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
+
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		if ( pmlmeext->channel_set[i].ChannelNum == 1)
+			index_24G = i;
+		if ( pmlmeext->channel_set[i].ChannelNum == 36)
+			index_5G = i;
+	}	
+	
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		// 2.4G
+		if ( pmlmeext->channel_set[i].ChannelNum == 6 ) {
+			if ( pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count ) {
+				index_24G = i;
+				best_channel_24G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		// 5G
+		if ( pmlmeext->channel_set[i].ChannelNum >= 36
+			&& pmlmeext->channel_set[i].ChannelNum < 140 ) {
+			 // Find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 36) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		if ( pmlmeext->channel_set[i].ChannelNum >= 149
+			&& pmlmeext->channel_set[i].ChannelNum < 165) {
+			 // find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 149) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+#if 1 // debug
+		seq_printf(m, "The rx cnt of channel %3d = %d\n", 
+				pmlmeext->channel_set[i].ChannelNum, pmlmeext->channel_set[i].rx_count);
+#endif
+	}
+	seq_printf(m, "best_channel_5G = %d\n", best_channel_5G);
+	seq_printf(m, "best_channel_24G = %d\n", best_channel_24G);
+	return 0;
+}
+#endif
+
 #endif /* CONFIG_FIND_BEST_CHANNEL */
 	
 #endif
diff --git a/core/rtw_mp.c b/core/rtw_mp.c
index 0cdc094..bb76dae 100644
--- a/core/rtw_mp.c
+++ b/core/rtw_mp.c
@@ -1140,8 +1140,7 @@ void SetPacketTx(PADAPTER padapter)
 	_rtw_memset(ptr, payload, pkt_end - ptr);
 
 	//3 6. start thread
-	pmp_priv->tx.PktTxThread = kernel_thread(mp_xmit_packet_thread, pmp_priv, CLONE_FS|CLONE_FILES);
-	if(pmp_priv->tx.PktTxThread < 0)
+	if(!start_kthread(&pmp_priv->tx.PktTxThread, mp_xmit_packet_thread, pmp_priv, "8192cu-mp-xmit"))
 		DBG_871X("Create PktTx Thread Fail !!!!!\n");
 
 }
diff --git a/hal/rtl8192c/usb/usb_halinit.c b/hal/rtl8192c/usb/usb_halinit.c
index eb5ea29..6cac2d5 100644
--- a/hal/rtl8192c/usb/usb_halinit.c
+++ b/hal/rtl8192c/usb/usb_halinit.c
@@ -3786,6 +3786,8 @@ _ReadIDs(
 				pHalData->CustomerID = RT_CID_DLINK;
 			else if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x330a))
 				pHalData->CustomerID = RT_CID_DLINK;
+			else if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x330d))
+				pHalData->CustomerID = RT_CID_DLINK;
 			break;
 		case EEPROM_CID_WHQL:
 /*			
diff --git a/include/osdep_service.h b/include/osdep_service.h
index 2802187..6fedff4 100644
--- a/include/osdep_service.h
+++ b/include/osdep_service.h
@@ -100,6 +100,9 @@
 	#include <linux/pci.h>
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0))
+	#include <linux/kthread.h>
+#endif
 	
 #ifdef CONFIG_USB_HCI
 	typedef struct urb *  PURB;
@@ -133,8 +136,12 @@
 	//typedef u32	_irqL;
 	typedef unsigned long _irqL;
 	typedef	struct	net_device * _nic_hdl;
-	
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0))
 	typedef pid_t		_thread_hdl_;
+#else
+	typedef struct task_struct * _thread_hdl_;
+#endif
 	typedef int		thread_return;
 	typedef void*	thread_context;
 
@@ -572,7 +579,7 @@ __inline static void thread_enter(void *context)
 #ifdef PLATFORM_LINUX
 	//struct net_device *pnetdev = (struct net_device *)context;
 	//daemonize("%s", pnetdev->name);
-	daemonize("%s", "RTKTHREAD");
+	//daemonize("%s", "RTKTHREAD");
 	allow_signal(SIGTERM);
 #endif
 }
@@ -827,4 +834,8 @@ extern u64 rtw_division64(u64 x, u64 y);
 
 #endif
 
+#ifdef PLATFORM_LINUX
+extern int start_kthread(_thread_hdl_ *t_hdl, int (*threadfn)(void *data),
+			 void *data, const char *name);
+#endif
 
diff --git a/include/rtw_debug.h b/include/rtw_debug.h
index eca6692..624add6 100644
--- a/include/rtw_debug.h
+++ b/include/rtw_debug.h
@@ -24,7 +24,6 @@
 #include <osdep_service.h>
 #include <drv_types.h>
 
-
 #define _drv_emerg_			1
 #define _drv_alert_			2
 #define _drv_crit_			3
@@ -35,7 +34,6 @@
 #define _drv_dump_			8
 #define	_drv_debug_		9
 
-
 #define 	_module_rtl871x_xmit_c_ 		BIT(0)
 #define 	_module_xmit_osdep_c_ 		BIT(1)
 #define 	_module_rtl871x_recv_c_ 		BIT(2)
@@ -179,7 +177,6 @@ extern void rtl871x_cedbg(const char *fmt, ...);
 
 #endif /* CONFIG_DEBUG_RTL871X */
 
-
 #if	defined (_dbgdump) && defined (_MODULE_DEFINE_)
 
 		#undef RT_TRACE
@@ -193,7 +190,6 @@ extern void rtl871x_cedbg(const char *fmt, ...);
 
 #endif
 
-
 #if	defined (_dbgdump)
 
 		#undef  _func_enter_
@@ -231,7 +227,6 @@ extern void rtl871x_cedbg(const char *fmt, ...);
 			}
 #endif
 
-
 #ifdef CONFIG_DEBUG_RTL819X
 	#ifdef PLATFORM_WINDOWS
 
@@ -281,10 +276,9 @@ extern void rtl871x_cedbg(const char *fmt, ...);
 	#define ERR_8192C _dbgdump
 #endif
 
-
-
 #ifdef CONFIG_PROC_DEBUG
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	int proc_get_drv_version(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
@@ -293,8 +287,8 @@ extern void rtl871x_cedbg(const char *fmt, ...);
 			  off_t offset, int count,
 			  int *eof, void *data);
 
- 	int proc_set_write_reg(struct file *file, const char *buffer,
-		unsigned long count, void *data);
+	int proc_set_write_reg(struct file *file, const char *buffer,
+			  unsigned long count, void *data);
 
 	int proc_get_read_reg(char *page, char **start,
 			  off_t offset, int count,
@@ -303,7 +297,6 @@ extern void rtl871x_cedbg(const char *fmt, ...);
 	int proc_set_read_reg(struct file *file, const char *buffer,
 		unsigned long count, void *data);
 
-
 	int proc_get_fwstate(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
@@ -339,28 +332,75 @@ extern void rtl871x_cedbg(const char *fmt, ...);
 	int proc_get_trx_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
+#else
+	int proc_get_drv_version(struct seq_file *m, void *data);
+
+	int proc_get_write_reg(struct seq_file *m, void *data);
+
+ 	ssize_t proc_set_write_reg(struct file *file, const char *buffer,
+			 size_t count, loff_t *pos);
+
+	int proc_get_read_reg(struct seq_file *m, void *data);
+
+	ssize_t proc_set_read_reg(struct file *file, const char *buffer,
+			 size_t count, loff_t *pos);
+
+	int proc_get_fwstate(struct seq_file *m, void *data);
+
+	int proc_get_sec_info(struct seq_file *m, void *data);
+
+	int proc_get_mlmext_state(struct seq_file *m, void *data);
 
+	int proc_get_qos_option(struct seq_file *m, void *data);
+
+	int proc_get_ht_option(struct seq_file *m, void *data);
+
+	int proc_get_rf_info(struct seq_file *m, void *data);
+
+	int proc_get_ap_info(struct seq_file *m, void *data);
+
+	int proc_get_adapter_state(struct seq_file *m, void *data);
+
+	int proc_get_trx_info(struct seq_file *m, void *data);
+#endif
 
 #ifdef CONFIG_AP_MODE
 
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	int proc_get_all_sta_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
+# else
+	int proc_get_all_sta_info(struct seq_file *m, void *data);
+# endif
 
 #endif
 
 #ifdef DBG_MEMORY_LEAK
+
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	int proc_get_malloc_cnt(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
+# else
+	int proc_get_malloc_cnt(struct seq_file *m, void *data);
+# endif
+
 #endif
 
 #ifdef CONFIG_FIND_BEST_CHANNEL
+
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	int proc_get_best_channel(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
+# else
+	int proc_get_best_channel(struct seq_file *m, void *data);
+# endif
+
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	int proc_get_rx_signal(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
@@ -381,7 +421,22 @@ extern void rtl871x_cedbg(const char *fmt, ...);
 
 	int proc_set_rssi_disp(struct file *file, const char *buffer,
 		unsigned long count, void *data);
-	
+#else
+	int proc_get_rx_signal(struct seq_file *m, void *data);
+
+	ssize_t proc_set_rx_signal(struct file *file, const char *buffer,
+				size_t count, loff_t *pos);
+
+	int proc_get_ampdu_enable(struct seq_file *m, void *data);
+			  
+	ssize_t proc_set_ampdu_enable(struct file *file, const char *buffer,
+				size_t count, loff_t *pos);
+
+	int proc_get_rssi_disp(struct seq_file *m, void *data);
+
+	ssize_t proc_set_rssi_disp(struct file *file, const char *buffer,
+				size_t count, loff_t *pos);
+#endif
 
 #endif //CONFIG_PROC_DEBUG
 
diff --git a/include/rtw_recv.h b/include/rtw_recv.h
index a88f505..e204ef3 100644
--- a/include/rtw_recv.h
+++ b/include/rtw_recv.h
@@ -623,8 +623,9 @@ __inline static union recv_frame *rxmem_to_recvframe(u8 *rxmem)
 	//from any given member of recv_frame.
 	// rxmem indicates the any member/address in recv_frame
 	
-	return (union recv_frame*)(((uint)rxmem>>RXFRAME_ALIGN) <<RXFRAME_ALIGN) ;
-	
+	//return (union recv_frame*)(((uint)rxmem>>RXFRAME_ALIGN) <<RXFRAME_ALIGN) ;
+	//return (union recv_frame*)(((SIZE_PTR)rxmem >> RXFRAME_ALIGN) << RXFRAME_ALIGN);
+	return (union recv_frame*)(((ulong)rxmem>>RXFRAME_ALIGN) <<RXFRAME_ALIGN) ; 
 }
 
 __inline static union recv_frame *pkt_to_recvframe(_pkt *pkt)
diff --git a/os_dep/linux/os_intfs.c b/os_dep/linux/os_intfs.c
index 4d057a6..d3b662c 100644
--- a/os_dep/linux/os_intfs.c
+++ b/os_dep/linux/os_intfs.c
@@ -255,6 +255,246 @@ static char rtw_proc_name[IFNAMSIZ];
 static struct proc_dir_entry *rtw_proc = NULL;
 static int	rtw_proc_cnt = 0;
 
+/*
+ * seq_file wrappers for procfile show routines, kernel >= 3.10
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+
+static int proc_get_drv_version_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_drv_version, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_drv_version_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_drv_version_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_write_reg_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_write_reg, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_write_reg_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_write_reg_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.write = proc_set_write_reg,
+	.release = seq_release,
+};
+
+static int proc_get_read_reg_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_read_reg, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_read_reg_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_read_reg_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.write = proc_set_read_reg,
+	.release = seq_release,
+};
+
+static int proc_get_rssi_disp_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_rssi_disp, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_rssi_disp_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_rssi_disp_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.write = proc_set_rssi_disp,
+	.release = seq_release,
+};
+
+static int proc_get_ampdu_enable_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_ampdu_enable, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_ampdu_enable_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_ampdu_enable_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.write = proc_set_ampdu_enable,
+	.release = seq_release,
+};
+
+static int proc_get_rx_signal_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_rx_signal, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_rx_signal_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_rx_signal_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.write = proc_set_rx_signal,
+	.release = seq_release,
+};
+
+static int proc_get_fwstate_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_fwstate, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_fwstate_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_fwstate_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_mlmext_state_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_mlmext_state, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_mlmext_state_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_mlmext_state_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_qos_option_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_qos_option, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_qos_option_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_qos_option_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_ht_option_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_ht_option, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_ht_option_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_ht_option_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_rf_info_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_rf_info, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_rf_info_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_rf_info_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_ap_info_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_ap_info, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_ap_info_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_ap_info_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_adapter_state_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_adapter_state, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_adapter_state_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_adapter_state_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_trx_info_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_trx_info, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_trx_info_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_trx_info_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_sec_info_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_sec_info, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_sec_info_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_sec_info_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+# ifdef CONFIG_AP_MODE
+
+static int proc_get_all_sta_info_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_all_sta_info, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_all_sta_info_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_all_sta_info_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+# endif
+
+# ifdef DBG_MEMORY_LEAK
+
+static int proc_get_malloc_cnt_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_malloc_cnt, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_malloc_cnt_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_malloc_cnt_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+# endif
+
+# ifdef CONFIG_FIND_BEST_CHANNEL
+
+static int proc_get_best_channel_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_best_channel, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_best_channel_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_best_channel_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+# endif
+
+#endif
+
 void rtw_proc_init_one(struct net_device *dev)
 {
 	struct proc_dir_entry *dir_dev = NULL;
@@ -275,28 +515,37 @@ void rtw_proc_init_one(struct net_device *dev)
 #if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
 		rtw_proc=create_proc_entry(rtw_proc_name, S_IFDIR, proc_net);
 #else
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 		rtw_proc=create_proc_entry(rtw_proc_name, S_IFDIR, init_net.proc_net);
+# else
+		rtw_proc=proc_mkdir(rtw_proc_name, init_net.proc_net);
+# endif
 #endif
 		if (rtw_proc == NULL) {
 			DBG_8192C(KERN_ERR "Unable to create rtw_proc directory\n");
 			return;
 		}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 		entry = create_proc_read_entry("ver_info", S_IFREG | S_IRUGO, rtw_proc, proc_get_drv_version, dev);				   
+#else
+		entry = proc_create_data("ver_info", S_IFREG | S_IRUGO, rtw_proc, &proc_get_drv_version_fops, dev);				   
+#endif
 		if (!entry) {
 			DBG_871X("Unable to create_proc_read_entry!\n"); 
 			return;
 		}
 	}
 
-	
-
 	if(padapter->dir_dev == NULL)
 	{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 		padapter->dir_dev = create_proc_entry(dev->name, 
 					  S_IFDIR | S_IRUGO | S_IXUGO, 
 					  rtw_proc);
-
+#else
+		padapter->dir_dev = proc_mkdir(dev->name,rtw_proc);
+#endif
 		dir_dev = padapter->dir_dev;
 
 		if(dir_dev==NULL)
@@ -324,84 +573,127 @@ void rtw_proc_init_one(struct net_device *dev)
 
 	rtw_proc_cnt++;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("write_reg", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_write_reg, dev);				   
+#else
+	entry = proc_create_data("write_reg", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_write_reg_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry->write_proc = proc_set_write_reg;
 
 	entry = create_proc_read_entry("read_reg", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_read_reg, dev);				   
+#else
+	entry = proc_create_data("read_reg", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_read_reg_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry->write_proc = proc_set_read_reg;
 
-	
 	entry = create_proc_read_entry("fwstate", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_fwstate, dev);				   
+#else
+	entry = proc_create_data("fwstate", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_fwstate_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("sec_info", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_sec_info, dev);				   
+#else
+	entry = proc_create_data("sec_info", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_sec_info_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("mlmext_state", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_mlmext_state, dev);				   
+#else
+	entry = proc_create_data("mlmext_state", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_mlmext_state_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("qos_option", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_qos_option, dev);				   
+#else
+	entry = proc_create_data("qos_option", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_qos_option_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("ht_option", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_ht_option, dev);				   
+#else
+	entry = proc_create_data("ht_option", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_ht_option_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("rf_info", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_rf_info, dev);				   
+#else
+	entry = proc_create_data("rf_info", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_rf_info_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("ap_info", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_ap_info, dev);				   
+#else
+	entry = proc_create_data("ap_info", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_ap_info_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("adapter_state", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_adapter_state, dev);				   
+#else
+	entry = proc_create_data("adapter_state", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_adapter_state_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("trx_info", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_trx_info, dev);				   
+#else
+	entry = proc_create_data("trx_info", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_trx_info_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
@@ -409,56 +701,93 @@ void rtw_proc_init_one(struct net_device *dev)
 
 #ifdef CONFIG_AP_MODE
 
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("all_sta_info", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_all_sta_info, dev);				   
+# else
+	entry = proc_create_data("all_sta_info", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_all_sta_info_fops, dev);				   
+# endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
+
 #endif
 
 #ifdef DBG_MEMORY_LEAK
+
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("_malloc_cnt", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_malloc_cnt, dev);				   
+# else
+	entry = proc_create_data("_malloc_cnt", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_malloc_cnt_fops, dev);				   
+# endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
+
 #endif
 
 #ifdef CONFIG_FIND_BEST_CHANNEL
+
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("best_channel", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_best_channel, dev);				   
+# else
+	entry = proc_create_data("best_channel", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_best_channel_fops, dev);				   
+# endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
+
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("rx_signal", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_rx_signal, dev);				   
+#else
+	entry = proc_create_data("rx_signal", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_rx_signal_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry->write_proc = proc_set_rx_signal;
 
 	entry = create_proc_read_entry("ampdu_enable", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_ampdu_enable, dev);				   
+#else
+	entry = proc_create_data("ampdu_enable", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_ampdu_enable_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry->write_proc = proc_set_ampdu_enable;
 
 	entry = create_proc_read_entry("rssi_disp", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_rssi_disp, dev);				   
+#else
+	entry = proc_create_data("rssi_disp", S_IFREG | S_IRUGO,
+				   dir_dev, &proc_get_rssi_disp_fops, dev);				   
+#endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry->write_proc = proc_set_rssi_disp;
-
+#endif
 }
 
 void rtw_proc_remove_one(struct net_device *dev)
@@ -797,27 +1126,22 @@ u32 rtw_start_drv_threads(_adapter *padapter)
 	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_start_drv_threads\n"));
 
 #ifdef CONFIG_SDIO_HCI
-	padapter->xmitThread = kernel_thread(rtw_xmit_thread, padapter, CLONE_FS|CLONE_FILES);
-	if(padapter->xmitThread < 0)
+	if(!start_kthread(&padapter->xmitThread, rtw_xmit_thread, padapter, "8192cu-xmit"))
 		_status = _FAIL;
 #endif
 
 #ifdef CONFIG_RECV_THREAD_MODE
-	padapter->recvThread = kernel_thread(recv_thread, padapter, CLONE_FS|CLONE_FILES);
-	if(padapter->recvThread < 0)
+	if(!start_kthread(&padapter->recvThread, recv_thread, padapter, "8192cu-recv"))
 		_status = _FAIL;	
 #endif
 
-	padapter->cmdThread = kernel_thread(rtw_cmd_thread, padapter, CLONE_FS|CLONE_FILES);
-	if(padapter->cmdThread < 0)
+	if(!start_kthread(&padapter->cmdThread, rtw_cmd_thread, padapter, "8192cu-cmd"))
 		_status = _FAIL;
 	else
 		_rtw_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema); //wait for cmd_thread to run
-		
 
 #ifdef CONFIG_EVENT_THREAD_MODE
-	padapter->evtThread = kernel_thread(event_thread, padapter, CLONE_FS|CLONE_FILES);
-	if(padapter->evtThread < 0)
+	if(!start_kthread(&padapter->evtThread, event_thread, padapter, "8192cu-evt"))
 		_status = _FAIL;		
 #endif
 
diff --git a/os_dep/linux/usb_intf.c b/os_dep/linux/usb_intf.c
index 134acdc..f9a01e9 100644
--- a/os_dep/linux/usb_intf.c
+++ b/os_dep/linux/usb_intf.c
@@ -99,7 +99,9 @@ static struct usb_device_id rtw_usb_id_tbl[] ={
 	{USB_DEVICE(0x2019, 0xED17)},//PCI - Edimax
 	{USB_DEVICE(0x0DF6, 0x0052)},//Sitecom - Edimax
 	{USB_DEVICE(0x7392, 0x7811)},//Edimax - Edimax
+	{USB_DEVICE(0x07B8, 0x8188)},//Abocom - Abocom
 	{USB_DEVICE(0x07B8, 0x8189)},//Abocom - Abocom
+	{USB_DEVICE(0x0846, 0x9041)},//NetGear WNA1000M
 	{USB_DEVICE(0x0EB0, 0x9071)},//NO Brand - Etop
 	{USB_DEVICE(0x06F8, 0xE033)},//Hercules - Edimax
 	{USB_DEVICE(0x103C, 0x1629)},//HP - Lite-On ,8188CUS Slim Combo
@@ -137,6 +139,7 @@ static struct usb_device_id rtw_usb_id_tbl[] ={
 	{USB_DEVICE(0x2001, 0x3307)},//D-Link - Cameo
 	{USB_DEVICE(0x2001, 0x330A)},//D-Link - Alpha
 	{USB_DEVICE(0x2001, 0x3309)},//D-Link - Alpha
+	{USB_DEVICE(0x2001, 0x330D)},//D-Link - Alpha(?)
 	{USB_DEVICE(0x0586, 0x341F)},//Zyxel - Abocom
 	{USB_DEVICE(0x7392, 0x7822)},//Edimax - Edimax
 	{USB_DEVICE(0x2019, 0xAB2B)},//Planex - Abocom
diff --git a/os_dep/osdep_service.c b/os_dep/osdep_service.c
index 04cb35f..343cd82 100644
--- a/os_dep/osdep_service.c
+++ b/os_dep/osdep_service.c
@@ -1553,3 +1553,19 @@ u64 rtw_division64(u64 x, u64 y)
 #endif
 }
 
+#ifdef PLATFORM_LINUX
+int start_kthread(_thread_hdl_ *t_hdl, int (*threadfn)(void *data),
+		  void *data, const char *name)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0))
+	*t_hdl = kernel_thread(threadfn, data, CLONE_FS|CLONE_FILES);
+	if(*t_hdl < 0)
+#else
+	*t_hdl = kthread_run(threadfn, data, name);
+	if(IS_ERR(*t_hdl))
+#endif
+		return 0;
+	return -1;
+}
+#endif
+
